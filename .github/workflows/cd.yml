name: CD Pipeline

on:
  push:
    branches: [ "main" ]

env:
  REGISTRY: ghcr.io

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Lowercase Repo Owner
        run: echo "REPO_OWNER=${GITHUB_REPOSITORY_OWNER,,}" >> $GITHUB_ENV

      - name: Log in to the Container registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push API image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: apps/api/Dockerfile
          push: true
          # Tags both specific SHA (for stability) and latest (for convenience)
          tags: |
            ghcr.io/${{ env.REPO_OWNER }}/modular-house-api:${{ github.sha }}
            ghcr.io/${{ env.REPO_OWNER }}/modular-house-api:latest

      - name: Build and push Web image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: apps/web/Dockerfile
          push: true
          tags: |
            ghcr.io/${{ env.REPO_OWNER }}/modular-house-web:${{ github.sha }}
            ghcr.io/${{ env.REPO_OWNER }}/modular-house-web:latest
          build-args: |
            # API is served through Traefik at /api path (see docker-compose.prod.yml)
            VITE_API_BASE_URL=https://${{ secrets.DOMAIN_NAME }}/api
            GENERATE_SOURCEMAP=false

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Lowercase Repo Owner
        run: echo "REPO_OWNER=${GITHUB_REPOSITORY_OWNER,,}" >> $GITHUB_ENV

      - name: Debug Secret
        run: |
          if [ -z "$MY_KEY" ]; then
            echo "::error::The secret is EMPTY! Check if SSH key exist."
          else
            echo "The secret is present. Lenght: ${#MY_KEY}"
          fi
        env:
          MY_KEY: ${{ secrets.SERVER_SSH_KEY }}

      - name: Create .env file
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          SHADOW_DATABASE_URL: ${{secrets.SHADOW_DATABASE_URL}}
          ACME_EMAIL: ${{ secrets.ACME_EMAIL }}
          DOMAIN_NAME: ${{ secrets.DOMAIN_NAME }}
          MAIL_HOST: ${{ secrets.MAIL_HOST }}
          MAIL_PORT: ${{ secrets.MAIL_PORT }}
          MAIL_SECURE: ${{ secrets.MAIL_SECURE }}
          MAIL_USER: ${{ secrets.MAIL_USER }}
          MAIL_PASS: ${{ secrets.MAIL_PASS }}
          MAIL_FROM_NAME: ${{ secrets.MAIL_FROM_NAME }}
          MAIL_FROM_EMAIL: ${{ secrets.MAIL_FROM_EMAIL }}
          MAIL_INTERNAL_TO: ${{ secrets.MAIL_INTERNAL_TO }}
          MAIL_REJECT_UNAUTHORIZED: ${{ secrets.MAIL_REJECT_UNAUTHORIZED }}
          CUSTOMER_CONFIRM_ENABLED: ${{ secrets.CUSTOMER_CONFIRM_ENABLED }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          JWT_EXPIRES_IN: ${{ secrets.JWT_EXPIRES_IN}}
          PASSWORD_SALT_ROUNDS: ${{ secrets.PASSWORD_SALT_ROUNDS }}
          IP_SALT: ${{ secrets.IP_SALT }}
          ROBOTS_ALLOW: ${{ secrets.ROBOTS_ALLOW }}
          ADMIN_LOGIN_EMAIL: ${{ secrets.ADMIN_LOGIN_EMAIL }}
          ADMIN_LOGIN_PASSWORD: ${{ secrets.ADMIN_LOGIN_PASSWORD }}
          GA_TRACKING_ID: ${{ secrets.GA_TRACKING_ID }}
          REPO_OWNER: ${{ env.REPO_OWNER }}
          GITHUB_SHA: ${{ github.sha }}
        run: |
          # Create local .env
          touch .env

          # Runtime configuration
          printf "# Runtime configuration\n" >> .env;
          printf "NODE_ENV=production\n" >> .env;
          printf "PORT=8080\n" >> .env;
          printf "\n" >> .env;

          # Database secrets
          printf "# Database secrets\n" >> .env;
          if [ ! -z "$DATABASE_URL" ]; then 
            # Verify DATABASE_URL format before writing
            if echo "$DATABASE_URL" | grep -qE "^postgres(ql)?://"; then
              printf "DATABASE_URL=%s\n" "$DATABASE_URL" >> .env
              echo "DATABASE_URL written successfully (starts with postgres://)"
            else
              echo "::error::DATABASE_URL does not start with postgres:// or postgresql://"
              echo "DATABASE_URL value (first 20 chars): ${DATABASE_URL:0:20}..."
              exit 1
            fi
          else
            echo "::error::DATABASE_URL secret is empty!"
            exit 1
          fi
          if [ ! -z "$SHADOW_DATABASE_URL" ]; then printf "SHADOW_DATABASE_URL=%s\n" "$SHADOW_DATABASE_URL" >> .env; fi
          printf "\n" >> .env;

          # Certification email
          printf "# Certification email\n" >> .env;
          if [ ! -z "$ACME_EMAIL" ]; then printf "ACME_EMAIL=%s\n" "$ACME_EMAIL" >> .env; fi
          printf "\n" >> .env;

          # URL and API URL configuration
          printf "# URL and API URL configuration\n" >> .env;
          if [ ! -z "$DOMAIN_NAME" ]; then 
            printf "DOMAIN_NAME=%s\n" "$DOMAIN_NAME" >> .env;
            printf "VITE_API_BASE_URL=https://${{ secrets.DOMAIN_NAME }}/api\n" >> .env;
            printf "CORS_ORIGIN=https://%s,https://www.%s\n" "$DOMAIN_NAME" "$DOMAIN_NAME" >> .env;
          fi
          printf "\n" >> .env;

          # ghcr configuration
          printf "# ghcr configuration\n" >> .env;
          printf "GITHUB_USER_NAME=%s\n" "$REPO_OWNER" >> .env
          printf "IMAGE_TAG=%s\n" "$GITHUB_SHA" >> .env
          printf "\n" >> .env;
          
          # Mail configuration
          printf "# Mail configuration\n" >> .env;
          if [ ! -z "$MAIL_HOST" ]; then printf "MAIL_HOST=%s\n" "$MAIL_HOST" >> .env; fi
          if [ ! -z "$MAIL_PORT" ]; then printf "MAIL_PORT=%s\n" "$MAIL_PORT" >> .env; fi
          if [ ! -z "$MAIL_SECURE" ]; then printf "MAIL_SECURE=%s\n" "$MAIL_SECURE" >> .env; fi
          if [ ! -z "$MAIL_USER" ]; then printf "MAIL_USER=%s\n" "$MAIL_USER" >> .env; fi
          if [ ! -z "$MAIL_PASS" ]; then printf "MAIL_PASS=%s\n" "$MAIL_PASS" >> .env; fi
          if [ ! -z "$MAIL_FROM_NAME" ]; then printf "MAIL_FROM_NAME=%s\n" "$MAIL_FROM_NAME" >> .env; fi
          if [ ! -z "$MAIL_FROM_EMAIL" ]; then printf "MAIL_FROM_EMAIL=%s\n" "$MAIL_FROM_EMAIL" >> .env; fi
          if [ ! -z "$MAIL_INTERNAL_TO" ]; then printf "MAIL_INTERNAL_TO=%s\n" "$MAIL_INTERNAL_TO" >> .env; fi
          if [ ! -z "$MAIL_REJECT_UNAUTHORIZED" ]; then printf "MAIL_REJECT_UNAUTHORIZED=%s\n" "$MAIL_REJECT_UNAUTHORIZED" >> .env; fi
          if [ ! -z "$CUSTOMER_CONFIRM_ENABLED" ]; then printf "CUSTOMER_CONFIRM_ENABLED=%s\n" "$CUSTOMER_CONFIRM_ENABLED" >> .env; fi
          printf "\n" >> .env;

          # Security configuration
          printf "# Security configuration\n" >> .env;
          if [ ! -z "$JWT_SECRET" ]; then printf "JWT_SECRET=%s\n" "$JWT_SECRET" >> .env; fi
          if [ ! -z "$JWT_EXPIRES_IN" ]; then printf "JWT_EXPIRES_IN=%s\n" "$JWT_EXPIRES_IN" >> .env; fi
          if [ ! -z "$PASSWORD_SALT_ROUNDS" ]; then printf "PASSWORD_SALT_ROUNDS=%s\n" "$PASSWORD_SALT_ROUNDS" >> .env; fi
          if [ ! -z "$IP_SALT" ]; then printf "IP_SALT=%s\n" "$IP_SALT" >> .env; fi
          printf "\n" >> .env;

          # SEO & Robots
          printf "# SEO & Robots\n" >> .env;
          if [ ! -z "$ROBOTS_ALLOW" ]; then printf "ROBOTS_ALLOW=%s\n" "$ROBOTS_ALLOW" >> .env; fi
          printf "\n" >> .env;

          # Admin login configuration
          printf "# Admin login configuration\n" >> .env;
          if [ ! -z "$ADMIN_LOGIN_EMAIL" ]; then printf "ADMIN_LOGIN_EMAIL=%s\n" "$ADMIN_LOGIN_EMAIL" >> .env; fi
          if [ ! -z "$ADMIN_LOGIN_PASSWORD" ]; then printf "ADMIN_LOGIN_PASSWORD=%s\n" "$ADMIN_LOGIN_PASSWORD" >> .env; fi
          printf "\n" >> .env;

          # Google Analytics
          printf "# Google Analytics\n" >> .env;
          if [ ! -z "$GA_TRACKING_ID" ]; then printf "GA_TRACKING_ID=%s\n" "$GA_TRACKING_ID" >> .env; fi
          printf "\n" >> .env;
     
      - name: Create App Directory
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          script: mkdir -p ~/app

      - name: Copy files to server
        uses: appleboy/scp-action@v1.0.0
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          source: ".env,docker-compose.prod.yml"
          target: "~/app"
          debug: true

      - name: Verify files on server
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          debug: true
          script: |
            set -e
            cd ~/app || exit 1
            echo "=== Files in ~/app ==="
            if [ -f .env ]; then
              echo ".env file exists with $(wc -l < .env) lines"
              
              # Show structure without values
              echo "=== Environment variables present: ==="
              grep -E "^[A-Z_]+=" .env | cut -d= -f1 | sort
              
              # Verify DATABASE_URL format in the file
              echo "=== DATABASE_URL verification: ==="
              if grep -q "^DATABASE_URL=" .env; then
                # We use parameter expansion ${var#*=} to safely handle passwords containing '='
                DB_LINE=$(grep "^DATABASE_URL=" .env)
                DB_FULL_VAL="${DB_LINE#*=}"
                DB_URL_PREFIX=$(echo "$DB_FULL_VAL" | cut -c1-15)
                
                echo "DATABASE_URL starts with: ${DB_URL_PREFIX}..."
                
                if echo "$DB_URL_PREFIX" | grep -qE "^postgres"; then
                  echo "DATABASE_URL format looks correct"
                else
                  echo "DATABASE_URL may have incorrect format"
                  echo "First 30 chars: $(echo "$DB_FULL_VAL" | cut -c1-30)"
                fi
              else
                echo "::error::DATABASE_URL not found in .env file!"
                exit 1
              fi
            else
              echo "::error::.env file was NOT created!"
              exit 1
            fi

      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          debug: true
          script: |
            set -e
            cd ~/app
            
            # Secure the .env file
            chmod 600 .env
            
            # Pull and restart
            docker compose -f docker-compose.prod.yml pull
            docker compose -f docker-compose.prod.yml up -d --remove-orphans
            docker image prune -f
            
            # Wait for containers to start
            echo "=== Waiting for containers to start ==="
            sleep 10
            
            # Debug: Check what DATABASE_URL the container sees
            echo "=== Checking DATABASE_URL in container ==="
            docker compose -f docker-compose.prod.yml exec -T api sh -c 'echo "DATABASE_URL starts with: $(echo $DATABASE_URL | cut -c1-20)..."' || echo "Could not check DATABASE_URL"
            
            # Run database migrations inside the API container
            echo "=== Running database migrations ==="
            docker compose -f docker-compose.prod.yml exec -T api npx prisma migrate deploy || {
              echo "Migration failed - checking container logs..."
              docker compose -f docker-compose.prod.yml logs --tail=50 api
              exit 1
            }
            
            echo "=== Container status ==="
            docker compose -f docker-compose.prod.yml ps
            
            echo "=== API container logs (last 30 lines) ==="
            docker compose -f docker-compose.prod.yml logs --tail=30 api || echo "No API logs available"